// Code generated by resourcegeneration. DO NOT EDIT.
// Source: ./pkg/resources

package app

import (
	"context"
	"net/http"

	"github.com/cccteam/ccc"
	"github.com/cccteam/ccc/accesstypes"
	"github.com/cccteam/ccc/resource"
	"github.com/cccteam/demo-app/pkg/resources"
	"github.com/cccteam/httpio"
	"github.com/go-playground/errors/v5"
	"go.opentelemetry.io/otel"
)

func (a *App) PatchResources() http.HandlerFunc {
	type userRequest struct {
		Id       ccc.UUID `json:"-"`
		Username string   `json:"username"`
	}
	userDecoder := NewDecoder[resources.User, userRequest](a, accesstypes.Create, accesstypes.Update, accesstypes.Delete)

	type response map[string][]ccc.UUID

	return httpio.Log(func(w http.ResponseWriter, r *http.Request) error {
		ctx, span := otel.Tracer(name).Start(r.Context(), "App.PatchResources()")
		defer span.End()

		var (
			eventSource = resource.UserEvent(ctx)
			resp        response
		)

		if err := a.ResourceClient().ExecuteFunc(ctx, func(ctx context.Context, txn resource.ReadWriteTransaction) error {
			resp = response{}
			r, err := resource.CloneRequest(r)
			if err != nil {
				return errors.Wrap(err, "resource.CloneRequest()")
			}

			for op, err := range resource.Operations(r, "/{resource}", resource.MatchPrefix()) {
				if err != nil {
					return errors.Wrap(err, "resource.Operations()")
				}

				switch httpio.Param[string](op.Req, "resource") {
				case "users":
					patchSet, err := userDecoder.DecodeOperation(op, a.UserPermissions(op.Req))
					if err != nil {
						return errors.Wrap(err, "userDecoder.DecodeOperation()")
					}

					req, err := op.ReqWithPattern("/{resource}/{id}")
					if err != nil {
						return errors.Wrap(err, "op.ReqWithPattern()")
					}

					switch op.Type {
					case resource.OperationCreate:
						patch, err := resources.NewUserCreatePatchFromPatchSet(patchSet)
						if err != nil {
							return errors.Wrap(err, "userCreatePatchFromPatchSet()")
						}
						if err := patch.PatchSet().Buffer(ctx, txn, eventSource); err != nil {
							return errors.Wrap(handleError[resources.User](err), "resources.UserCreatePatch.Buffer()")
						}
						resp["users"] = append(resp["users"], patch.Id())
					case resource.OperationUpdate:
						id := httpio.Param[ccc.UUID](req, "id")
						if err := resources.NewUserUpdatePatchFromPatchSet(id, patchSet).PatchSet().Buffer(ctx, txn, eventSource); err != nil {
							return errors.Wrap(handleError[resources.User](err), "resources.UserUpdatePatch.Buffer()")
						}
					case resource.OperationDelete:
						id := httpio.Param[ccc.UUID](req, "id")
						if err := resources.NewUserDeletePatchFromPatchSet(id, patchSet).PatchSet().Buffer(ctx, txn, eventSource); err != nil {
							return errors.Wrap(handleError[resources.User](err), "resources.UserDeletePatch.Buffer()")
						}
					}
				default:
					return httpio.NewBadRequestMessagef("unknown resource %q", httpio.Param[string](op.Req, "resource"))
				}
			}

			return nil
		}); err != nil {
			return httpio.NewEncoder(w).ClientMessage(ctx, err)
		}

		return httpio.NewEncoder(w).Ok(resp)
	})
}
