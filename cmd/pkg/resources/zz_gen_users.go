// Code generated by resourcegeneration. DO NOT EDIT.
// Source: ./pkg/resources

package resources

import (
	"github.com/cccteam/ccc"
	"github.com/cccteam/ccc/accesstypes"
	"github.com/cccteam/ccc/resource"
	"github.com/go-playground/errors/v5"
)

func (User) Resource() accesstypes.Resource {
	return "Users"
}

func (User) DefaultConfig() resource.Config {
	return defaultConfig()
}

type UserQuery struct {
	qSet *resource.QuerySet[User]
}

func NewUserQuery() *UserQuery {
	return &UserQuery{qSet: resource.NewQuerySet(resource.NewMetadata[User]())}
}

func NewUserQueryFromQuerySet(qSet *resource.QuerySet[User]) *UserQuery {
	return &UserQuery{qSet: qSet}
}

func (q *UserQuery) SetId(v ccc.UUID) *UserQuery {
	q.qSet.SetKey("Id", v)

	return q
}

func (q *UserQuery) Id() ccc.UUID {
	v, _ := q.qSet.Key("Id").(ccc.UUID)

	return v
}

func (q *UserQuery) Query() *resource.QuerySet[User] {
	return q.qSet
}

func (q *UserQuery) AddColumns(c *UserColumns) *UserQuery {
	for _, field := range c.fields {
		q.qSet.AddField(field)
	}

	return q
}

func (q *UserQuery) Where(c UserQueryClause) *UserQuery {
	if err := c.clause.Validate(); err != nil {
		panic(err)
	}
	q.qSet.SetWhereClause(c.clause)

	return q
}

func (q *UserQuery) Sort(sort *UserSort) *UserQuery {
	q.qSet.SetSortFields(sort.sortFields)

	return q
}

func (q *UserQuery) Limit(n uint64) *UserQuery {
	q.qSet.SetLimit(&n)

	return q
}

func (q *UserQuery) Offset(n uint64) *UserQuery {
	q.qSet.SetOffset(&n)

	return q
}

type UserColumns struct {
	fields []accesstypes.Field
}

func NewUserColumns() *UserColumns {
	return &UserColumns{}
}

func (c *UserColumns) All() *UserColumns {
	c.fields = []accesstypes.Field{
		"Id",
		"Username",
	}

	return c
}

func (c *UserColumns) Id() *UserColumns {
	c.fields = append(c.fields, "Id")

	return c
}

func (c *UserColumns) Username() *UserColumns {
	c.fields = append(c.fields, "Username")

	return c
}

type UserQueryPartialClause struct {
	partialClause resource.PartialQueryClause
}

func NewUserQueryClause() UserQueryPartialClause {
	return UserQueryPartialClause{partialClause: resource.NewPartialQueryClause()}
}

func (p UserQueryPartialClause) Group(qc UserQueryClause) UserQueryClause {
	return UserQueryClause{clause: p.partialClause.Group(qc.clause)}
}

func (p UserQueryPartialClause) Id() UserQueryIdent[ccc.UUID] {
	return UserQueryIdent[ccc.UUID]{Ident: resource.NewIdent[ccc.UUID]("Id", p.partialClause, true)}
}

type UserQueryClause struct {
	clause resource.QueryClause
}

func (qc UserQueryClause) And() UserQueryPartialClause {
	return UserQueryPartialClause{partialClause: qc.clause.And()}
}

func (qc UserQueryClause) Or() UserQueryPartialClause {
	return UserQueryPartialClause{partialClause: qc.clause.Or()}
}

type UserQueryIdent[T comparable] struct {
	resource.Ident[T]
}

func (i UserQueryIdent[T]) Equal(v ...T) UserQueryClause {
	return UserQueryClause{clause: i.Ident.Equal(v...)}
}

func (i UserQueryIdent[T]) NotEqual(v ...T) UserQueryClause {
	return UserQueryClause{clause: i.Ident.NotEqual(v...)}
}

func (i UserQueryIdent[T]) GreaterThan(v T) UserQueryClause {
	return UserQueryClause{clause: i.Ident.GreaterThan(v)}
}

func (i UserQueryIdent[T]) GreaterThanEq(v T) UserQueryClause {
	return UserQueryClause{clause: i.Ident.GreaterThanEq(v)}
}

func (i UserQueryIdent[T]) LessThan(v T) UserQueryClause {
	return UserQueryClause{clause: i.Ident.LessThan(v)}
}

func (i UserQueryIdent[T]) LessThanEq(v T) UserQueryClause {
	return UserQueryClause{clause: i.Ident.LessThanEq(v)}
}

func (i UserQueryIdent[T]) IsNull() UserQueryClause {
	return UserQueryClause{clause: i.Ident.IsNull()}
}

func (i UserQueryIdent[T]) IsNotNull() UserQueryClause {
	return UserQueryClause{clause: i.Ident.IsNotNull()}
}

type UserSortBuilder struct {
	*userSort
}

func NewUserSort() *UserSortBuilder {
	return &UserSortBuilder{userSort: &userSort{}}
}

type userSort struct {
	sortFields []resource.SortField
}

func (c *userSort) addField(field string) *UserSort {
	c.sortFields = append(c.sortFields, resource.SortField{Field: field, Direction: resource.SortAscending})

	return &UserSort{userSort: c}
}

func (c *userSort) Id() *UserSort {
	return c.addField("Id")
}

func (c *userSort) Username() *UserSort {
	return c.addField("Username")
}

type UserSort struct {
	*userSort
}

func (s *UserSort) Asc() *UserSort {
	s.sortFields[len(s.sortFields)-1].Direction = resource.SortAscending

	return s
}

func (s *UserSort) Desc() *UserSort {
	s.sortFields[len(s.sortFields)-1].Direction = resource.SortDescending

	return s
}

type UserCreatePatch struct {
	patchSet *resource.PatchSet[User]
}

func NewUserCreatePatchFromPatchSet(patchSet *resource.PatchSet[User]) (*UserCreatePatch, error) {
	id, err := ccc.NewUUID()
	if err != nil {
		return nil, errors.Wrap(err, "ccc.NewUUID()")
	}

	patchSet.
		SetKey("Id", id).
		SetPatchType(resource.CreatePatchType)
	patch := &UserCreatePatch{patchSet: patchSet}
	patch.registerDefaultFuncs()

	return patch, nil
}

func NewUserCreatePatch() (*UserCreatePatch, error) {
	id, err := ccc.NewUUID()
	if err != nil {
		return nil, errors.Wrap(err, "ccc.NewUUID()")
	}

	patchSet := resource.NewPatchSet(resource.NewMetadata[User]()).
		SetKey("Id", id).
		SetPatchType(resource.CreatePatchType)
	patch := &UserCreatePatch{patchSet: patchSet}
	patch.registerDefaultFuncs()

	return patch, nil
}

func (p *UserCreatePatch) PatchSet() *resource.PatchSet[User] {
	return p.patchSet
}

func (p *UserCreatePatch) registerDefaultFuncs() {
}

func (p *UserCreatePatch) Id() ccc.UUID {
	v, _ := p.patchSet.Key("Id").(ccc.UUID)

	return v
}

func (p *UserCreatePatch) SetUsername(v string) *UserCreatePatch {
	p.patchSet.Set("Username", v)

	return p
}

func (p *UserCreatePatch) Username() string {
	v, _ := p.patchSet.Get("Username").(string)

	return v
}

func (p *UserCreatePatch) UsernameIsSet() bool {
	return p.patchSet.IsSet("Username")
}

type UserUpdatePatch struct {
	patchSet *resource.PatchSet[User]
}

func NewUserUpdatePatchFromPatchSet(id ccc.UUID, patchSet *resource.PatchSet[User]) *UserUpdatePatch {
	patchSet.
		SetKey("Id", id).
		SetPatchType(resource.UpdatePatchType)

	patch := &UserUpdatePatch{patchSet: patchSet}
	patch.registerDefaultFuncs()

	return patch
}

func NewUserUpdatePatch(id ccc.UUID) *UserUpdatePatch {
	patchSet := resource.NewPatchSet(resource.NewMetadata[User]()).
		SetKey("Id", id).
		SetPatchType(resource.UpdatePatchType)

	patch := &UserUpdatePatch{patchSet: patchSet}
	patch.registerDefaultFuncs()

	return patch
}

func (p *UserUpdatePatch) PatchSet() *resource.PatchSet[User] {
	return p.patchSet
}

func (p *UserUpdatePatch) registerDefaultFuncs() {
}

func (p *UserUpdatePatch) Id() ccc.UUID {
	v, _ := p.patchSet.Key("Id").(ccc.UUID)

	return v
}

func (p *UserUpdatePatch) SetUsername(v string) *UserUpdatePatch {
	p.patchSet.Set("Username", v)

	return p
}

func (p *UserUpdatePatch) Username() string {
	v, _ := p.patchSet.Get("Username").(string)

	return v
}

func (p *UserUpdatePatch) UsernameIsSet() bool {
	return p.patchSet.IsSet("Username")
}

type UserDeletePatch struct {
	patchSet *resource.PatchSet[User]
}

func NewUserDeletePatchFromPatchSet(id ccc.UUID, patchSet *resource.PatchSet[User]) *UserDeletePatch {
	patchSet.
		SetKey("Id", id).
		SetPatchType(resource.DeletePatchType)

	return &UserDeletePatch{patchSet: patchSet}
}

func NewUserDeletePatch(id ccc.UUID) *UserDeletePatch {
	patchSet := resource.NewPatchSet(resource.NewMetadata[User]()).
		SetKey("Id", id).
		SetPatchType(resource.DeletePatchType)

	return &UserDeletePatch{patchSet: patchSet}
}

func (p *UserDeletePatch) PatchSet() *resource.PatchSet[User] {
	return p.patchSet
}

func (p *UserDeletePatch) Id() ccc.UUID {
	v, _ := p.patchSet.Key("Id").(ccc.UUID)

	return v
}
